{"mappings":"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","sources":["node_modules/gl-matrix/esm/common.js","node_modules/web-gl-helpers/dist/src/AttributeClass.js","node_modules/web-gl-helpers/dist/src/Texture2DClass.js","main.js","node_modules/web-gl-helpers/dist/src/HelperFunctions.js"],"sourcesContent":["/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","/**\r\n * Created by Rick on 2021-12-11.\r\n */\r\n'use strict';\r\n\r\n/**\r\n * AttributeClass provides functions for working with a WebGLProgram's attribute variable.\r\n *   The class establishes a data buffer for sending vertex attributes, such as vertex coordinates,\r\n *   texture coordinate data, or vertex color data through the graphics hardware pipeline.\r\n *   See [WebGL Fundamentals](https://webgl2fundamentals.org/webgl/lessons/webgl-fundamentals.html) for\r\n *   an explanation on data buffers.\r\n *\r\n */\r\nexport default class AttributeClass {\r\n  /**\r\n   * Create an AttributeClass instance\r\n   * @param {WebGLRenderingContext} gl The WebGL context\r\n   * @param {number} type  Specifying the [data type]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer}\r\n   *   of each component in the array.\r\n   * @param {WebGLProgram} program The WebGL program.\r\n   * @param {string} name The name of the attribute variable.\r\n   */\r\n  constructor(gl, type, program, name) {\r\n    this.gl = gl;\r\n    this.type = type;\r\n    // Look up where the attribute needs to go\r\n    this.attributeLocation = this.gl.getAttribLocation(program, name);\r\n    this.buffer = this.gl.createBuffer();\r\n  }\r\n\r\n  /**\r\n   * Describes how the attribute is read from the buffer pipeline.\r\n   * @param {number} size  The number of components per vertex attribute. Must be 1, 2, 3, or 4.\r\n   * @param {boolean} normalize Specifying whether integer data values should be normalized.\r\n   * @param {number} stride Specifying the offset in bytes between the beginning of consecutive vertex attributes.\r\n   * @param {number} offset Specifying an offset in bytes of the first component in the vertex attribute array.\r\n   */\r\n  bufferFormat(size, normalize, stride, offset) {\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\r\n    // Tell the attribute how to get data out of the internal ARRAY_BUFFER\r\n    this.gl.vertexAttribPointer(\r\n      this.attributeLocation,\r\n      size,\r\n      this.type,\r\n      normalize,\r\n      stride,\r\n      offset\r\n    );\r\n    this.gl.enableVertexAttribArray(this.attributeLocation);\r\n  }\r\n\r\n  /**\r\n   * Initializes and creates the buffer object's data store.\r\n   * @param {number[]} attribute_list Array containing vertex attributes, such as vertex coordinates, texture coordinate data, or vertex color data.\r\n   * @param {number} usage Specifies the intended [usage pattern]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData} of the data store for optimization purposes.\r\n   */\r\n  setData(attribute_list, usage){\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\r\n    // Set geometry\r\n    switch(this.type){\r\n      case this.gl.FLOAT:\r\n        this.gl.bufferData(\r\n          this.gl.ARRAY_BUFFER,\r\n          new Float32Array(attribute_list),\r\n          usage\r\n        );\r\n      break;\r\n      case this.gl.UNSIGNED_BYTE:\r\n        this.gl.bufferData(\r\n          this.gl.ARRAY_BUFFER,\r\n          new Uint8Array(attribute_list),\r\n          usage\r\n        );\r\n        break;\r\n    }\r\n  }\r\n}","/**\r\n * Created by Rick on 2021-12-30.\r\n */\r\n'use strict';\r\n\r\n/**\r\n * Texture2DClass provides functions for setting and\r\n *   binding color or image\r\n *   [WebGLTexture object]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture}\r\n */\r\nexport default class Texture2DClass {\r\n  /**\r\n   * Create a Texture2DClass instance\r\n   * @param {WebGLRenderingContext} gl\r\n   */\r\n  constructor(gl) {\r\n    this.gl = gl;\r\n  }\r\n\r\n  /**\r\n   * Create a [WebGLTexture]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture} object\r\n   *   and define its color.\r\n   * @param {number[]} color_v4 A 4 element vector where the first three values are the RGB values for\r\n   *   the canvas background. The fourth is the alpha value.\r\n   */\r\n  setColor(color_v4){\r\n    // Bind to the TEXTURE_2D bind point of the unit\r\n    const texture = this.gl.createTexture();\r\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\r\n    // Fill the texture with a 1x1 colored pixel\r\n    this.gl.texImage2D(\r\n      this.gl.TEXTURE_2D,\r\n      0,\r\n      this.gl.RGBA,\r\n      1,\r\n      1,\r\n      0,\r\n      this.gl.RGBA,\r\n      this.gl.UNSIGNED_BYTE,\r\n      new Uint8Array(color_v4)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Create a [WebGLTexture]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLTexture} object.\r\n   *   Activate and bind the texture then set it initially to a\r\n   *   blue color while the image is loaded. The function is async\r\n   *   and returns a javascript Promise.\r\n   * @param {string} url The file path to the image to be used as a texture\r\n   */\r\n  async loadTexture(url) {\r\n    // Fill the texture with a 1x1 colored pixel\r\n    this.gl.texImage2D(\r\n      this.gl.TEXTURE_2D, //target\r\n      0,                  //level\r\n      this.gl.RGBA,       //internal format\r\n      1,                  //width\r\n      1,                  //height\r\n      0,                  //border\r\n      this.gl.RGBA,       //format\r\n      this.gl.UNSIGNED_BYTE,    //type\r\n      new Uint8Array([0, 0, 255, 255])  //pixel source\r\n    );\r\n\r\n    let response = await fetch(url);\r\n    let blob = await response.blob();\r\n    let image = await createImageBitmap(blob, {imageOrientation: 'flipY'});\r\n\r\n    const texture = this.gl.createTexture();\r\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\r\n\r\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);\r\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);\r\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\r\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\r\n\r\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\r\n  }\r\n}","/**\r\n * Created by Rick on 2022-01-20.\r\n */\r\n'use strict';\r\n\r\nimport {vertex_shader, fragment_shader} from \"./shaders.js\";\r\nimport {AttributeClass} from \"web-gl-helpers\";\r\nimport {Texture2DClass} from \"web-gl-helpers\";\r\nimport {resizeCanvasToDisplaySize} from \"web-gl-helpers\"\r\nimport {createShader} from \"web-gl-helpers\";\r\nimport {createGLcontext} from \"web-gl-helpers\";\r\nimport {createProgram} from \"web-gl-helpers\";\r\nimport {initializeContext} from \"web-gl-helpers\";\r\n\r\ntry {\r\n  const context = createGLcontext('my_canvas', 'webgl2');\r\n  const gl = context.gl;\r\n  const canvas = context.canvas;\r\n\r\n  // Check canvas width and height\r\n  resizeCanvasToDisplaySize(canvas);\r\n\r\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n  // Create shader objects\r\n  const vShader = createShader(gl, gl.VERTEX_SHADER, vertex_shader);\r\n  const fShader = createShader(gl, gl.FRAGMENT_SHADER, fragment_shader);\r\n\r\n  // Create a WebGLProgram\r\n  const program = createProgram(gl, vShader, fShader);\r\n  // Tell it to use our program (a pair of shaders)\r\n  gl.useProgram(program);\r\n\r\n  // Set up the 'a_coords_v2' coordinates attribute VBO\r\n  const coords =\r\n    [\r\n      -2.0, -1.0,  0.0,\r\n      -2.0,  1.0,  0.0,\r\n      0.0,  1.0,  0.0,\r\n\r\n      -2.0, -1.0,  0.0,\r\n      0.0,  1.0,  0.0,\r\n      0.0, -1.0,  0.0\r\n    ];\r\n  const coordsAttrib = new AttributeClass(gl, gl.FLOAT, program, 'a_coords_v3');\r\n  coordsAttrib.setData(coords, gl.STATIC_DRAW);\r\n\r\n  // Set up the 'a_texCoords_v2' coordinates attribute VBO\r\n  const  texCoords = [\r\n    0.0, 0.0,\r\n    0.0, 1.0,\r\n    1.0, 1.0,\r\n\r\n    0.0, 0.0,\r\n    1.0, 1.0,\r\n    1.0, 0.0\r\n  ];\r\n  const texCoordsAttrib = new AttributeClass(gl, gl.FLOAT, program, 'a_texCoords_v2');\r\n  texCoordsAttrib.setData(texCoords, gl.STATIC_DRAW);\r\n\r\n  // Associate shader attributes with corresponding data buffers\r\n  const vao = gl.createVertexArray();\r\n  // Make vao the one we're currently working with\r\n  gl.bindVertexArray(vao);\r\n\r\n  // Specify how to pull the coordinate data out set it\r\n  {\r\n    const size = 3; // 3 components per iteration\r\n    const normalize = false; // don't normalize the data\r\n    const stride = 0; // 0 = move forward size * sizeof(type) each\r\n    //  iteration to get the next position\r\n    const offset = 0; // start at the beginning of the buffer\r\n    coordsAttrib.bufferFormat(size, normalize, stride, offset);\r\n  }\r\n\r\n  {\r\n    const size = 2 // 2 components per iteration\r\n    const normalize = false; // normalize the data\r\n    const stride = 0; // 0 = move forward size * sizeof(type) each\r\n    //  iteration to get the next position\r\n    const offset = 0; // start at the beginning of the buffer\r\n    texCoordsAttrib.bufferFormat(size, normalize, stride, offset);\r\n  }\r\n\r\n  //Tell shader to use texture unit 0\r\n  const u_texture_unit_location = gl.getUniformLocation(program, \"u_sampler_unit\");\r\n  gl.uniform1i( u_texture_unit_location, 0);\r\n\r\n  // Create an instance of Texture2D\r\n  // Initialize a Texture2DClass and read/set an image\r\n  const texture2D = new Texture2DClass(gl);\r\n\r\n  /*texture2D.setColor([0, 0, 255, 255]);\r\n  initializeContext(gl);\r\n  gl.drawArrays(gl.TRIANGLES, 0, 6);*/\r\n\r\n  texture2D.loadTexture(\"brick.jpg\").then(() => {\r\n    // Draw the triangle\r\n    initializeContext(gl);\r\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n\r\n    gl.bindTexture(this.gl.TEXTURE_2D, null);\r\n  })\r\n}catch (e) {\r\n  console.log(e);\r\n}","/**\r\n * Created by Rick on 2022-01-11.\r\n */\r\n'use strict';\r\n\r\n/** @function createGLcontext\r\n * Create a WebGLRenderingContext from a canvas id.\r\n *\r\n * @param {string} canvas_id The html dom id for the canvas.\r\n * @param {string} context_type The context type. Acceptable values are '2d', 'webgl', 'webgl2', 'bitmaprenderer'.\r\n * @param {Object} options A set of options for the context. See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext}.\r\n * @returns {{gl: WebGLRenderingContext, canvas: HTMLElement}}\r\n */\r\nfunction createGLcontext(canvas_id, context_type='webgl2', options){\r\n  // One-time initialization of the scene.\r\n  const canvas = document.getElementById(canvas_id);\r\n  if(!canvas){\r\n    throw new Error(`createGLContext: Could not locate canvas element with id ${canvas_id}`);\r\n  }\r\n  // Create a WebGLRenderingContext\r\n  const gl = canvas.getContext(context_type, options);\r\n\r\n  return {\r\n    gl: gl,\r\n    canvas: canvas\r\n  };\r\n}\r\n\r\n/** @function\r\n * Initialize the WebGLRenderingContext by clearing the canvas and giving by default a white background.\r\n *\r\n * @param {WebGLRenderingContext} gl The WebGLRenderingContext to be initialized.\r\n * @param {number[]} color_v4 A 4 element vector where the first three values are the RGB values for\r\n *   the canvas background. The fourth is the alpha value.\r\n */\r\nfunction initializeContext(gl, color_v4 = [255.0,255.0,255.0,1.0]){\r\n  // Clear the canvas (red, gree, blue, alpha)\r\n  gl.enable(gl.BLEND);\r\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n  gl.clearColor(color_v4[0], color_v4[1], color_v4[2], color_v4[3]);  // clear to black, fully opaque\r\n  gl.clearDepth(1.0);  // clear everything\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n}\r\n\r\n/** @function\r\n * Check that the size of the canvas with the css values for width and height are the same.\r\n *\r\n * @param {HTMLElement} canvas The HTML canvas element whose size is to be checked.\r\n * @returns {boolean} Returns TRUE if the size was reassigned.\r\n */\r\nfunction resizeCanvasToDisplaySize(canvas){\r\n  // Lookup the size the browser is displaying the canvas in css pixels\r\n  const displayWidth = canvas.clientWidth;\r\n  const displayHeight = canvas.clientHeight;\r\n\r\n  // Check if the canvas is not the same size\r\n  const needResize = canvas.width !== displayWidth ||\r\n    canvas.height !== displayHeight;\r\n\r\n  if(needResize) {\r\n    // Make the canvas the same size\r\n    canvas.width = displayWidth;\r\n    canvas.height = displayHeight;\r\n  }\r\n\r\n  return needResize;\r\n}\r\n\r\n/** @function\r\n * Create a complete rendering program {WebGLProgram}\r\n *\r\n * @param {WebGLRenderingContext} gl The WebGL context from the canvas.\r\n * @param {WebGLShader} vertex_shader The program's vertex shader.\r\n * @param {WebGLShader} frag_shader The program's fragment shader.\r\n * @returns {WebGLProgram}\r\n */\r\nfunction createProgram(gl, vertex_shader, frag_shader){\r\n  const program = gl.createProgram();\r\n\r\n  // Attach the shader objects\r\n  gl.attachShader(program, vertex_shader);\r\n  gl.attachShader(program, frag_shader);\r\n\r\n  // Link the WebGLProgram object\r\n  gl.linkProgram(program);\r\n\r\n  // Check for success\r\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n\r\n  if(!success) {\r\n    const program_info = gl.getProgramInfoLog(program);\r\n    gl.deleteProgram(program);\r\n    throw new Error('createProgram: ' + program_info);\r\n  }else {\r\n    return program;\r\n  }\r\n}\r\n\r\n/** @function\r\n * Creates a shader object {WebGLShader} given\r\n *   the source code. See [WebGLShader]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLShader}\r\n *\r\n * @param {WebGLRenderingContext} gl The WebGL context from the canvas\r\n * @param {number} type The type of shader, either gl.VERTEX_SHADER or gl.FRAGMENT_SHADER.\r\n * @param {string} source The code/text of the shader.\r\n * @returns {WebGLShader}\r\n */\r\nfunction createShader(gl, type, source){\r\n  const shader = gl.createShader(type);\r\n  // Put the source code into the gl shader object\r\n  gl.shaderSource(shader, source);\r\n  // Compile the shader code\r\n  gl.compileShader(shader);\r\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n\r\n  if(!success){\r\n    const shader_info = gl.getShaderInfoLog(shader);\r\n    gl.deleteShader(shader);\r\n    throw new Error('createShader: ' + shader_info);\r\n  }else {\r\n    return shader;\r\n  }\r\n}\r\n\r\nexport{\r\n  createGLcontext,\r\n  initializeContext,\r\n  resizeCanvasToDisplaySize,\r\n  createProgram,\r\n  createShader\r\n}"],"names":["Float32Array","Math","random","PI","hypot","y","i","arguments","length","sqrt","$f8517097745e6edf$export$be1b00860175ea1f","constructor","gl","type","program","name","this","attributeLocation","getAttribLocation","buffer","createBuffer","bufferFormat","size","normalize","stride","offset","$f8517097745e6edf$export$32ce69a2ed5cf1a","setColor","color_v4","texture","createTexture","bindTexture","TEXTURE_2D","async","url1","texImage2D","RGBA","UNSIGNED_BYTE","Uint8Array","context","canvas_id","context_type","options","canvas","document","getElementById","Error","getContext","$f8517097745e6edf$export$904a8156d3f18680","displayWidth","clientWidth","displayHeight","clientHeight","needResize","width","height","$f8517097745e6edf$export$4d986a341d0b1b6c","viewport","vShader","$f8517097745e6edf$export$1750aa77609e1fb","VERTEX_SHADER","fShader","FRAGMENT_SHADER","vertex_shader","frag_shader","$f8517097745e6edf$export$327d24a04cd0dc17","useProgram","coords","coordsAttrib","FLOAT","setData","STATIC_DRAW","texCoords","texCoordsAttrib","vao","createVertexArray","bindVertexArray","u_texture_unit_location","getUniformLocation","uniform1i","loadTexture","then","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","clearColor","clearDepth","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","$f8517097745e6edf$export$881f7fb71351b304","drawArrays","TRIANGLES","undefined"],"version":3,"file":"index.b7884725.js.map"}